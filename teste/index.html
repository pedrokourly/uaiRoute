<!DOCTYPE html>
<html lang="pt-br">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rota Otimizada com OpenRouteService e Leaflet</title>

    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
        integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />

    <style>
        #map {
            height: 600px;
            width: 100%;
        }
    </style>
</head>

<body>
    <h1>Problema do Caixeiro Viajante com Leaflet</h1>
    <p>Calculando a melhor rota entre Porto Alegre, Gramado e paradas intermediárias.</p>
    <div id="map"></div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
        integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mapbox-polyline/1.2.0/polyline.min.js"
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>

    <script>
        const apiKey = '5b3ce3597851110001cf62489715e0567dc24edd98bd95aee36637a9';

        const map = L.map('map').setView([-29.7, -51.2], 9);

        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
        }).addTo(map);

        function addMarker(latlng, text, color = 'blue') {
            const marker = L.marker(latlng).addTo(map);
            marker.bindPopup(text).openPopup();
            return marker;
        }

        async function getOptimizedRoute() {
            const startPoint = [-51.2177, -30.0346]; // Porto Alegre (Início)
            const endPoint = [-50.8764, -29.3794];   // Gramado (Fim)
            const waypoints = [
                [-51.1794, -29.1687], // Caxias do Sul
                [-51.1378, -29.6854], // Novo Hamburgo
                [-50.8497, -29.3653]  // Canela
            ];

            // Adiciona marcadores para os pontos iniciais, intermediários e finais
            addMarker([startPoint[1], startPoint[0]], 'Ponto de Partida', 'green');
            waypoints.forEach((point, index) => {
                addMarker([point[1], point[0]], `Parada ${index + 1}`, 'orange');
            });
            addMarker([endPoint[1], endPoint[0]], 'Ponto Final', 'red');

            // --- PRIMEIRA REQUISIÇÃO: Otimização para obter a ORDEM das paradas ---
            const optimizationRequestBody = {
                jobs: waypoints.map((point, index) => ({
                    id: index + 1,
                    location: point
                })),
                vehicles: [{
                    id: 1,
                    profile: 'driving-car',
                    start: startPoint,
                    end: endPoint
                }],
                // Aqui não precisamos de 'points: true', pois só queremos a ordem
            };

            try {
                const optResponse = await fetch('https://api.openrouteservice.org/optimization', {
                    method: 'POST',
                    headers: {
                        'Authorization': apiKey,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(optimizationRequestBody)
                });

                if (!optResponse.ok) {
                    const errorData = await optResponse.json();
                    throw new Error(`Erro na API de Otimização: ${optResponse.statusText} - ${JSON.stringify(errorData)}`);
                }

                const optData = await optResponse.json();
                console.log("Resposta de Otimização:", optData);

                if (optData.routes && optData.routes.length > 0) {
                    const optimizedRouteData = optData.routes[0];
                    console.log("Ordem otimizada das paradas:");

                    const orderedCoordinates = [];
                    // Adiciona o ponto de partida
                    orderedCoordinates.push(startPoint);

                    // Mapeia os 'steps' da rota otimizada para a ordem correta das coordenadas
                    optimizedRouteData.steps.forEach(step => {
                        // Certifica-se de adicionar apenas os pontos 'job' e 'end' intermediários na ordem otimizada
                        // O ponto 'start' já foi adicionado
                        if (step.type === 'job' || step.type === 'end') {
                            orderedCoordinates.push(step.location);
                        }
                        const coords = [step.location[1], step.location[0]]; // Para log, Leaflet usa [lat, lng]
                        console.log(`- ${step.type}: ${step.name || `Ponto ${step.id || ''}`} em [${coords.join(', ')}]`);
                    });

                    // Verifica se o ponto final já foi adicionado (se for 'end' do último step)
                    // Caso contrário, adiciona-o explicitamente no final para garantir
                    const lastStepIsEnd = optimizedRouteData.steps[optimizedRouteData.steps.length - 1]?.type === 'end';
                    if (!lastStepIsEnd && !orderedCoordinates.some(coord => coord[0] === endPoint[0] && coord[1] === endPoint[1])) {
                         orderedCoordinates.push(endPoint);
                    }
                    
                    // Remove duplicatas se startPoint ou endPoint aparecerem nos jobs
                    // Uma forma simples é converter para string e usar Set, depois converter de volta
                    const uniqueOrderedCoordinates = Array.from(new Set(orderedCoordinates.map(JSON.stringify))).map(JSON.parse);


                    console.log("Coordenadas na ordem para a rota detalhada:", uniqueOrderedCoordinates);

                    // --- SEGUNDA REQUISIÇÃO: Direções para obter a GEOMETRIA da rota ---
                    const directionsRequestBody = {
                        coordinates: uniqueOrderedCoordinates, // Pontos na ordem otimizada
                        profile: 'driving-car',
                        format: 'json',
                        geometry: 'true', // Solicita a geometria
                        instructions: 'false' // Não precisamos das instruções passo a passo para desenhar
                    };

                    const directionsResponse = await fetch('https://api.openrouteservice.org/v2/directions/driving-car/json', {
                        method: 'POST',
                        headers: {
                            'Authorization': apiKey,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(directionsRequestBody)
                    });

                    if (!directionsResponse.ok) {
                        const errorData = await directionsResponse.json();
                        throw new Error(`Erro na API de Direções: ${directionsResponse.statusText} - ${JSON.stringify(errorData)}`);
                    }

                    const directionsData = await directionsResponse.json();
                    console.log("Resposta de Direções (com geometria):", directionsData);

                    if (directionsData.routes && directionsData.routes.length > 0) {
                        const routeGeometry = directionsData.routes[0].geometry; // A geometria está aqui!

                        if (routeGeometry) {
                            const decodedPath = polyline.decode(routeGeometry); // Decodifica a polyline
                            console.log("Caminho decodificado:", decodedPath);

                            // Desenha a Rota no Mapa
                            const routePolyline = L.polyline(decodedPath, {
                                color: 'blue',
                                weight: 5,
                                opacity: 0.7
                            }).addTo(map);

                            // Ajusta o Zoom do Mapa para a rota completa
                            map.fitBounds(routePolyline.getBounds());
                        } else {
                            console.warn("A geometria não foi encontrada na resposta das direções.");
                        }

                    } else {
                        console.warn("Nenhuma rota detalhada foi retornada pelas direções.");
                    }

                } else {
                    console.warn("Nenhuma rota otimizada foi retornada da primeira requisição.");
                }

            } catch (error) {
                console.error('Falha geral ao buscar a rota:', error);
            }
        }

        getOptimizedRoute();
    </script>
</body>

</html>